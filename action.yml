name: vibecheck-scan
description: "Unified static analysis with intelligent issue creation for AI-driven development"
author: "WolffM"

branding:
  icon: "shield"
  color: "purple"

inputs:
  cadence:
    description: "Analysis cadence: daily, weekly, or monthly"
    required: false
    default: "weekly"
  severity_threshold:
    description: "Minimum severity for issues: critical, high, medium, low, info"
    required: false
    default: "medium"
  confidence_threshold:
    description: "Minimum confidence for issues: high, medium, low"
    required: false
    default: low
  skip_issues:
    description: "Skip GitHub issue creation/updates"
    required: false
    default: "false"
  config_path:
    description: "Path to vibecheck.yml config file"
    required: false
    default: "vibecheck.yml"
  github_token:
    description: "GitHub token for issue management"
    required: true
  create_config_pr:
    description: "Create a PR with generated config files (.trunk/, etc.) if they don't exist. Requires contents:write and pull-requests:write permissions."
    required: false
    default: "false"
  autofix_prs:
    description: "Create PRs for findings with safe autofixes (ESLint formatting, Ruff style). Requires contents:write and pull-requests:write permissions."
    required: false
    default: "false"

outputs:
  total_findings:
    description: Total number of findings
    value: ${{ steps.analyze.outputs.total_findings }}
  issues_created:
    description: "Number of issues created"
    value: ${{ steps.analyze.outputs.issues_created }}
  issues_updated:
    description: "Number of issues updated"
    value: ${{ steps.analyze.outputs.issues_updated }}
  issues_closed:
    description: "Number of issues closed"
    value: ${{ steps.analyze.outputs.issues_closed }}
  sarif_path:
    description: "Path to generated SARIF file"
    value: ${{ steps.analyze.outputs.sarif_path }}
  llm_json_path:
    description: "Path to generated LLM JSON file"
    value: ${{ steps.analyze.outputs.llm_json_path }}

runs:
  using: composite
  steps:
    - name: Setup Node.js
      uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020 # v4.4.0
      with:
        node-version: "20"

    - name: Setup pnpm
      uses: pnpm/action-setup@eae0cfeb286e66ffb5155f1a79b90583a127a68b # v2.4.1
      with:
        version: 9

    - name: Install vibeCheck dependencies
      shell: bash
      run: |
        cd ${{ github.action_path }}
        pnpm install --frozen-lockfile

    - name: Setup Trunk
      uses: trunk-io/trunk-action/setup@4d5ecc89b2691705fd08c747c78652d2fc806a94 # v1.1.19

    - name: Setup Python
      uses: actions/setup-python@a26af69be951a213d495a4c3e4e4022e16d87065 # v5.6.0
      with:
        python-version: "3.11"

    - name: Detect Python files
      id: detect-python
      shell: bash
      run: |
        # Check for Python project files (more reliable than just .py files)
        if [ -n "$(find "${{ github.workspace }}" \( -name "pyproject.toml" -o -name "setup.py" -o -name "requirements.txt" -o -name "Pipfile" \) 2>/dev/null | head -1)" ]; then
          echo "has_python=true" >> $GITHUB_OUTPUT
          echo "Python project files detected"
        elif [ -n "$(find "${{ github.workspace }}" -name "*.py" -type f -not -path "*/node_modules/*" -not -path "*/.git/*" 2>/dev/null | head -1)" ]; then
          echo "has_python=true" >> $GITHUB_OUTPUT
          echo "Python source files detected"
        else
          echo "has_python=false" >> $GITHUB_OUTPUT
          echo "No Python files detected"
        fi

    - name: Install Python Analysis Tools
      shell: bash
      run: |
        # Always install semgrep for security scanning (works on all code, not just Python)
        pip install semgrep

        # Install Python-specific tools only if Python files detected
        if [ "${{ steps.detect-python.outputs.has_python }}" == "true" ]; then
          echo "Installing Python analysis tools (ruff, mypy, bandit)..."
          pip install ruff mypy bandit
        else
          echo "Skipping Python-specific tools (no Python files detected)"
        fi

    - name: Install JS/TS Analysis Tools
      shell: bash
      run: |
        # Install dependency-cruiser and knip globally for cross-repo analysis
        # These tools work without config files (depcruise uses --no-config, knip auto-detects)
        npm install -g dependency-cruiser knip

    - name: Install Target Repo JS Dependencies
      shell: bash
      run: |
        # Install target repo's node dependencies for ESLint and TypeScript analysis
        # This is needed for modern ESLint configs that import packages
        cd "${{ github.workspace }}"
        if [ -f "package.json" ]; then
          if [ -f "pnpm-lock.yaml" ]; then
            echo "Installing dependencies with pnpm..."
            pnpm install --frozen-lockfile || pnpm install
          elif [ -f "yarn.lock" ]; then
            echo "Installing dependencies with yarn..."
            yarn install --frozen-lockfile || yarn install
          elif [ -f "package-lock.json" ]; then
            echo "Installing dependencies with npm..."
            npm ci || npm install
          else
            echo "Installing dependencies with npm (no lockfile)..."
            npm install
          fi
        else
          echo "No package.json found, skipping JS dependency installation"
        fi

    - name: Detect Java files
      id: detect-java
      shell: bash
      run: |
        # Check for Java project files OR Java source files
        if [ -n "$(find "${{ github.workspace }}" -name "pom.xml" -o -name "build.gradle" -o -name "build.gradle.kts" 2>/dev/null | head -1)" ]; then
          echo "has_java=true" >> $GITHUB_OUTPUT
          echo "Java project files detected"
        elif [ -n "$(find "${{ github.workspace }}" -name "*.java" -type f 2>/dev/null | head -1)" ]; then
          echo "has_java=true" >> $GITHUB_OUTPUT
          echo "Java source files detected"
        else
          echo "has_java=false" >> $GITHUB_OUTPUT
          echo "No Java files detected"
        fi

    - name: Setup Java (if needed)
      if: steps.detect-java.outputs.has_java == 'true'
      uses: actions/setup-java@c1e323688fd81a25caa38c78aa6df2d33d3e20d9 # v4.8.0
      with:
        distribution: temurin
        java-version: "17"

    - name: Install PMD (if Java detected)
      if: steps.detect-java.outputs.has_java == 'true'
      shell: bash
      run: |
        echo "Installing PMD..."
        PMD_VERSION="7.0.0"
        curl -L "https://github.com/pmd/pmd/releases/download/pmd_releases%2F${PMD_VERSION}/pmd-dist-${PMD_VERSION}-bin.zip" -o pmd.zip
        unzip -q pmd.zip -d /tmp
        echo "/tmp/pmd-bin-${PMD_VERSION}/bin" >> $GITHUB_PATH

    - name: Install SpotBugs (if Java detected)
      if: steps.detect-java.outputs.has_java == 'true'
      shell: bash
      run: |
        echo "Installing SpotBugs..."
        SPOTBUGS_VERSION="4.8.3"
        curl -L "https://github.com/spotbugs/spotbugs/releases/download/${SPOTBUGS_VERSION}/spotbugs-${SPOTBUGS_VERSION}.tgz" -o spotbugs.tgz
        tar -xzf spotbugs.tgz -C /tmp
        echo "/tmp/spotbugs-${SPOTBUGS_VERSION}/bin" >> $GITHUB_PATH

    - name: Compile Java files for SpotBugs (if Java detected)
      if: steps.detect-java.outputs.has_java == 'true'
      shell: bash
      run: |
        echo "Compiling Java files for SpotBugs analysis..."
        WORKSPACE="${{ github.workspace }}"

        # Try Maven build first
        if [ -f "$WORKSPACE/pom.xml" ]; then
          echo "Found Maven project, running mvn compile..."
          cd "$WORKSPACE" && mvn compile -q -DskipTests 2>/dev/null || echo "Maven compile failed (non-fatal)"
        # Try Gradle build
        elif [ -f "$WORKSPACE/build.gradle" ] || [ -f "$WORKSPACE/build.gradle.kts" ]; then
          echo "Found Gradle project, running gradle compileJava..."
          cd "$WORKSPACE" && ./gradlew compileJava -q 2>/dev/null || gradle compileJava -q 2>/dev/null || echo "Gradle compile failed (non-fatal)"
        else
          # Fallback: compile standalone Java files to a target directory
          echo "No build system found, compiling standalone Java files..."
          JAVA_FILES=$(find "$WORKSPACE" -name "*.java" -type f -not -path "*/node_modules/*" -not -path "*/.git/*" 2>/dev/null)
          if [ -n "$JAVA_FILES" ]; then
            # Find directories containing Java files and compile each
            for dir in $(echo "$JAVA_FILES" | xargs -n1 dirname | sort -u); do
              TARGET_DIR="$dir/target/classes"
              mkdir -p "$TARGET_DIR"
              echo "Compiling Java files in $dir..."
              # Compile all Java files in this directory, ignoring errors
              find "$dir" -maxdepth 1 -name "*.java" -exec javac -d "$TARGET_DIR" {} + 2>/dev/null || echo "Some files failed to compile (non-fatal)"
            done
          fi
        fi

    - name: Detect Rust files
      id: detect-rust
      shell: bash
      run: |
        # Check for Rust project files (Cargo.toml) OR .rs files
        if [ -f "${{ github.workspace }}/Cargo.toml" ]; then
          echo "has_rust=true" >> $GITHUB_OUTPUT
          echo "Rust project detected (Cargo.toml found)"
        elif [ -n "$(find "${{ github.workspace }}" -name "*.rs" -type f -not -path "*/target/*" -not -path "*/.cargo/*" 2>/dev/null | head -1)" ]; then
          echo "has_rust=true" >> $GITHUB_OUTPUT
          echo "Rust source files detected"
        else
          echo "has_rust=false" >> $GITHUB_OUTPUT
          echo "No Rust files detected"
        fi

    - name: Setup Rust (if needed)
      if: steps.detect-rust.outputs.has_rust == 'true'
      uses: actions-rust-lang/setup-rust-toolchain@v1
      with:
        components: clippy

    - name: Install Rust Analysis Tools
      if: steps.detect-rust.outputs.has_rust == 'true'
      shell: bash
      run: |
        echo "Installing Rust analysis tools (cargo-audit, cargo-deny)..."
        cargo install cargo-audit cargo-deny --locked

    - name: Generate Cargo.lock files (for cargo-audit/deny)
      if: steps.detect-rust.outputs.has_rust == 'true'
      shell: bash
      run: |
        # Find all directories with Cargo.toml and generate Cargo.lock if missing
        find "${{ github.workspace }}" -name "Cargo.toml" -not -path "*/target/*" | while read cargo_toml; do
          dir=$(dirname "$cargo_toml")
          if [ ! -f "$dir/Cargo.lock" ]; then
            echo "Generating Cargo.lock in $dir..."
            (cd "$dir" && cargo generate-lockfile 2>/dev/null) || echo "  Failed to generate lockfile (non-fatal)"
          fi
        done

    - name: Run Analysis
      id: analyze
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github_token }}
        GITHUB_REPOSITORY: ${{ github.repository }}
      run: |
        OUTPUT_DIR="${{ github.workspace }}/.vibecheck-output"

        # Run the analysis
        npx tsx ${{ github.action_path }}/src/core/analyze.ts \
          --root "${{ github.workspace }}" \
          --cadence "${{ inputs.cadence }}" \
          --config "${{ inputs.config_path }}" \
          --output "$OUTPUT_DIR" \
          --severity-threshold "${{ inputs.severity_threshold }}" \
          --confidence-threshold "${{ inputs.confidence_threshold }}" \
          ${{ inputs.skip_issues == 'true' && '--skip-issues' || '' }}

        # Set outputs
        if [ -f "$OUTPUT_DIR/results.llm.json" ]; then
          echo "total_findings=$(jq '.summary.totalFindings // 0' $OUTPUT_DIR/results.llm.json)" >> $GITHUB_OUTPUT
          echo "issues_created=$(jq '.summary.issuesCreated // 0' $OUTPUT_DIR/results.llm.json)" >> $GITHUB_OUTPUT
          echo "issues_updated=$(jq '.summary.issuesUpdated // 0' $OUTPUT_DIR/results.llm.json)" >> $GITHUB_OUTPUT
          echo "issues_closed=$(jq '.summary.issuesClosed // 0' $OUTPUT_DIR/results.llm.json)" >> $GITHUB_OUTPUT
        else
          echo "total_findings=0" >> $GITHUB_OUTPUT
          echo "issues_created=0" >> $GITHUB_OUTPUT
          echo "issues_updated=0" >> $GITHUB_OUTPUT
          echo "issues_closed=0" >> $GITHUB_OUTPUT
        fi

        echo "sarif_path=$OUTPUT_DIR/results.sarif" >> $GITHUB_OUTPUT
        echo "llm_json_path=$OUTPUT_DIR/results.llm.json" >> $GITHUB_OUTPUT

    - name: Check if Code Scanning is available
      id: check-code-scanning
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github_token }}
      run: |
        # Check if the repo has code scanning enabled by trying to list alerts
        # This avoids the noisy error from codeql-action when it's not available
        if gh api "/repos/${{ github.repository }}/code-scanning/alerts" --silent 2>/dev/null; then
          echo "available=true" >> $GITHUB_OUTPUT
          echo "Code scanning is available"
        else
          echo "available=false" >> $GITHUB_OUTPUT
          echo "Code scanning not available (private repo without Advanced Security, or not enabled)"
        fi

    - name: Upload SARIF to Code Scanning
      # Note: This step requires:
      # - security-events: write permission
      # - GitHub Advanced Security enabled (for private repos)
      # Skipped if code scanning is not available
      if: steps.check-code-scanning.outputs.available == 'true' && hashFiles('.vibecheck-output/results.sarif') != ''
      continue-on-error: true
      uses: github/codeql-action/upload-sarif@5d4e8d1aca955e8d8589aabd499c5cae939e33c7 # v4.31.9
      with:
        sarif_file: .vibecheck-output/results.sarif
        category: vibeCheck

    - name: Generate Summary
      shell: bash
      run: |
        OUTPUT_DIR="${{ github.workspace }}/.vibecheck-output"

        if [ -f "$OUTPUT_DIR/results.llm.json" ]; then
          echo "## üõ°Ô∏è vibeCheck Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          TOTAL=$(jq '.summary.totalFindings // 0' $OUTPUT_DIR/results.llm.json)
          CREATED=$(jq '.summary.issuesCreated // 0' $OUTPUT_DIR/results.llm.json)
          UPDATED=$(jq '.summary.issuesUpdated // 0' $OUTPUT_DIR/results.llm.json)
          CLOSED=$(jq '.summary.issuesClosed // 0' $OUTPUT_DIR/results.llm.json)

          echo "| Metric | Count |" >> $GITHUB_STEP_SUMMARY
          echo "|--------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Total Findings | $TOTAL |" >> $GITHUB_STEP_SUMMARY
          echo "| Issues Created | $CREATED |" >> $GITHUB_STEP_SUMMARY
          echo "| Issues Updated | $UPDATED |" >> $GITHUB_STEP_SUMMARY
          echo "| Issues Closed | $CLOSED |" >> $GITHUB_STEP_SUMMARY

          # Show suppressed findings if any exist (below severity/confidence threshold)
          SUPPRESSED_TOTAL=$(jq '.summary.suppressed.total // 0' $OUTPUT_DIR/results.llm.json)
          if [ "$SUPPRESSED_TOTAL" -gt 0 ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "<details>" >> $GITHUB_STEP_SUMMARY
            echo "<summary>‚ÑπÔ∏è <strong>$SUPPRESSED_TOTAL findings suppressed</strong> (below threshold)</summary>" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Severity | Suppressed |" >> $GITHUB_STEP_SUMMARY
            echo "|----------|------------|" >> $GITHUB_STEP_SUMMARY

            for sev in info low medium high critical; do
              COUNT=$(jq ".summary.suppressed.bySeverity.$sev // 0" $OUTPUT_DIR/results.llm.json)
              if [ "$COUNT" -gt 0 ]; then
                echo "| $sev | $COUNT |" >> $GITHUB_STEP_SUMMARY
              fi
            done

            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Adjust \`severity_threshold\` or \`confidence_threshold\` to see these findings." >> $GITHUB_STEP_SUMMARY
            echo "</details>" >> $GITHUB_STEP_SUMMARY
          fi
        fi

    - name: Create Config PR
      if: inputs.create_config_pr == 'true'
      continue-on-error: true
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github_token }}
      run: |
        # This step requires additional permissions:
        #   contents: write   - to push the branch
        #   pull-requests: write - to create the PR
        # If these aren't available, the step will fail gracefully.
        
        # Check if there are new config files to commit
        CONFIG_FILES=""
        
        # Check for .trunk directory (created by trunk init)
        if [ -d ".trunk" ]; then
          if ! git ls-files --error-unmatch .trunk/trunk.yaml &>/dev/null; then
            CONFIG_FILES="$CONFIG_FILES .trunk/"
            echo "Found new .trunk/ directory"
          fi
        fi
        
        # Check for other common config files that might have been created
        for file in .dependency-cruiser.cjs .jscpd.json pyrightconfig.json mypy.ini; do
          if [ -f "$file" ] && ! git ls-files --error-unmatch "$file" &>/dev/null; then
            CONFIG_FILES="$CONFIG_FILES $file"
            echo "Found new config file: $file"
          fi
        done
        
        # Exit early if no new config files
        if [ -z "$CONFIG_FILES" ]; then
          echo "No new config files to commit"
          exit 0
        fi
        
        echo "New config files to commit:$CONFIG_FILES"
        
        # Check if PR already exists
        BRANCH_NAME="vibecheck/add-config-files"
        EXISTING_PR=$(gh pr list --head "$BRANCH_NAME" --json number --jq '.[0].number' 2>/dev/null || echo "")
        
        if [ -n "$EXISTING_PR" ]; then
          echo "PR #$EXISTING_PR already exists for config files"
          exit 0
        fi
        
        # Configure git
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        
        # Create branch and commit
        git checkout -b "$BRANCH_NAME"
        git add $CONFIG_FILES
        git commit -m "chore: add vibeCheck config files"
        
        # Push branch
        git push origin "$BRANCH_NAME" --force
        
        # Create PR with simple body
        gh pr create \
          --title "chore: add vibeCheck config files" \
          --body "Adds configuration files generated by vibeCheck. These enable faster subsequent runs and can be customized." \
          --head "$BRANCH_NAME" \
          --base "${{ github.ref_name }}"

        echo "Created PR for config files"

    - name: Run Autofixes
      if: inputs.autofix_prs == 'true'
      continue-on-error: true
      shell: bash
      run: |
        OUTPUT_DIR="${{ github.workspace }}/.vibecheck-output"

        # Check if results exist
        if [ ! -f "$OUTPUT_DIR/results.llm.json" ]; then
          echo "No results file found, skipping autofix"
          exit 0
        fi

        # Run the TypeScript autofix runner
        # This runs fix commands for all tools with safe autofix findings
        echo "Running autofix commands..."
        npx tsx ${{ github.action_path }}/src/tools/run-autofix.ts \
          --results "$OUTPUT_DIR/results.llm.json" \
          --root "${{ github.workspace }}" \
          --output "$OUTPUT_DIR/autofix-results.json"

    - name: Create Autofix PRs
      if: inputs.autofix_prs == 'true'
      continue-on-error: true
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github_token }}
      run: |
        OUTPUT_DIR="${{ github.workspace }}/.vibecheck-output"
        AUTOFIX_RESULTS="$OUTPUT_DIR/autofix-results.json"

        # Check if autofix results exist
        if [ ! -f "$AUTOFIX_RESULTS" ]; then
          echo "No autofix results found, skipping PR creation"
          exit 0
        fi

        # Configure git
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"

        # Get short SHA for branch naming
        SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
        BASE_BRANCH="${{ github.ref_name }}"

        # Read tools that had successful fixes from autofix results
        TOOLS=$(jq -r '.results[] | select(.success == true and (.files | length) > 0) | .tool' "$AUTOFIX_RESULTS" 2>/dev/null)

        if [ -z "$TOOLS" ]; then
          echo "No tools with successful fixes, skipping PR creation"
          exit 0
        fi

        echo "Tools with fixes: $TOOLS"

        # Create PR for each tool
        for TOOL in $TOOLS; do
          echo ""
          echo "=== Creating PR for $TOOL ==="

          # Get files for this tool from autofix results
          FILES=$(jq -r ".results[] | select(.tool == \"$TOOL\") | .files[]" "$AUTOFIX_RESULTS" 2>/dev/null | tr '\n' ' ')

          if [ -z "$FILES" ] || [ "$FILES" = " " ]; then
            echo "No files for $TOOL, skipping"
            continue
          fi

          echo "Files: $FILES"

          # Use stable branch name (without SHA) to avoid duplicates
          BRANCH_NAME="vibecheck/autofix-$TOOL"

          # Check if PR already exists for this tool (any open PR with vibecheck/autofix-$TOOL prefix)
          EXISTING_PR=$(gh pr list --state open --json number,headRefName --jq ".[] | select(.headRefName | startswith(\"vibecheck/autofix-$TOOL\")) | .number" 2>/dev/null | head -1 || echo "")

          if [ -n "$EXISTING_PR" ]; then
            echo "PR #$EXISTING_PR already exists for $TOOL autofix, skipping"
            continue
          fi

          # Find related vibeCheck issue for this tool
          TOOL_UPPER=$(echo "$TOOL" | tr '[:lower:]' '[:upper:]')
          RELATED_ISSUE=$(gh issue list --label "tool:$TOOL" --label "vibeCheck" --state open --json number,title --jq '.[0] | "\(.number)|\(.title)"' 2>/dev/null || echo "")

          if [ -n "$RELATED_ISSUE" ]; then
            ISSUE_NUMBER=$(echo "$RELATED_ISSUE" | cut -d'|' -f1)
            ISSUE_TITLE=$(echo "$RELATED_ISSUE" | cut -d'|' -f2)
            PR_TITLE="fix: $ISSUE_TITLE"
            CLOSES_LINE="Closes #$ISSUE_NUMBER"
          else
            PR_TITLE="fix: auto-fix $TOOL issues"
            CLOSES_LINE=""
          fi

          # Create branch from base
          git checkout "$BASE_BRANCH"
          git checkout -b "$BRANCH_NAME"

          # Check if there are changes to commit
          if [ -z "$(git status --porcelain)" ]; then
            echo "No changes to commit for $TOOL"
            git checkout "$BASE_BRANCH"
            git branch -D "$BRANCH_NAME" 2>/dev/null || true
            continue
          fi

          # Add only the fixed files and commit
          git add $FILES 2>/dev/null || git add -A
          git commit -m "$PR_TITLE"
          git push origin "$BRANCH_NAME" --force

          # Create PR with link to issue
          PR_BODY="## Summary
        Automated fixes for safe $TOOL issues detected by vibeCheck.

        These are formatting/style fixes that are safe to apply automatically.

        $CLOSES_LINE

        ---
        Generated by [vibeCheck](https://github.com/WolffM/vibecheck)"

          gh pr create --title "$PR_TITLE" --body "$PR_BODY" --head "$BRANCH_NAME" --base "$BASE_BRANCH"

          echo "Created autofix PR for $TOOL"
          git checkout "$BASE_BRANCH"
        done

        echo ""
        echo "Autofix PR creation complete"
